{"meta":{"title":"Andrews的个人博客","subtitle":"","description":"","author":"andrews yang","url":"https://newbeenoob.github.io","root":"/"},"pages":[{"title":"我的标签","date":"2019-12-05T11:10:14.000Z","updated":"2019-12-05T14:08:12.843Z","comments":true,"path":"tags/index.html","permalink":"https://newbeenoob.github.io/tags/index.html","excerpt":"","text":""},{"title":"我的分类","date":"2019-12-05T11:13:52.000Z","updated":"2019-12-05T14:06:33.838Z","comments":true,"path":"categories/index.html","permalink":"https://newbeenoob.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"漫谈python特性：初识迭代器","slug":"blog2","date":"2019-12-07T14:03:02.000Z","updated":"2019-12-07T15:25:12.179Z","comments":true,"path":"posts/c2e18075/","link":"","permalink":"https://newbeenoob.github.io/posts/c2e18075/","excerpt":"","text":"先从可迭代对象讲起什么是可迭代对象？刚刚开始学习 python 的循环语句的时候；我们一定会接触到 for ... in 语句，我们通常使用 for.. in来 遍历 list, tupe ,string ,dict 等数据类型，所谓遍历；也就是把一个容器内的所有数据依次拿出来作赋值或者运算等其他操作。 在 python 中，迭代通常通过 for in来完成，例如列表的迭代： 1for item in ['a','b','c']:2 print(item)3...4...5a6b7c 我们也可以通过索引（也就是下标）的方式去取 ``list`` 中的元素，这种写法颇有 C/C++ 的风格： 1lst = [11,22,33]23for i in range(3):4 print(lst[i])5... list 这种数据类型虽然可以通过索引访问，但是很多其他的可迭代数据类型是没有索引的；不过，只要是可迭代对象，皆能通过 for in 来进行遍历。 1dct = &#123;'a':1,'b':2,'c':4&#125;2for key in dct:3 print(key)45# 默认情况下遍历字典类型是遍历它的 key 字符串也是可迭代对象;而本质上，列表，字符串以及元组对象都属于 序列 类型，他们有着共有的特性 —— 都可以从 0 开始索引访问；都可以进行切片操作。 值得一提的是；文件也是可迭代对象： 1with open('test.txt','r') as f:2 for line in f:3 print(line,end='')45## 结果即一行一行地打印文件里的内容 那么如何判断一个对象是否是可迭代对象呢？python 提供了一个内置函数 isinstance() 来判断某个对象是否属于某一已知的类型： 1&gt;&gt;&gt; isinstance([],Iterable)2&gt;&gt;&gt; True34&gt;&gt;&gt; isinstance('aaaaa',Iterable)5&gt;&gt;&gt; True67&gt;&gt;&gt; isinstance(10,Iterable)8&gt;&gt;&gt; False for循环的原理ok,现在我们来重新审视一下我们每天都会使用到的 for .. in语句； for 循环是基于迭代器协议的迭代工具的一种；除了 for 之外，in关键字，列表生成式，内置函数 map() 都是 python 中的迭代工具，那什么又叫迭代器协议呢? 迭代器协议： 对象必须提供一个next方法，执行该方法要么会返回迭代中下一项，要么就引起一个 Stoplteration 异常，以终止迭代。(只能往前走，撞到南墙就停下来) 。 解释了迭代器协议，可迭代对象的定义就清楚了；可迭代对象就是实现了迭代器协议的对象，通常对象内部都有一个 __iter__() 方法。 for 循环在处理需要迭代的数据时，会调用 __iter__() 方法，将它们变成一个迭代器，然后调用迭代器的 __next__() 方法进行取值；直到抛出 StopIteration 异常。 我们可以手写模拟python中的for循环： 1def manual_it(obj):2 obj_it = obj.__iter__()3 try:4 while True:5 print(l_it.__next__())6 except StopIteration:7 pass 用自定义类手动实现迭代器协议： 1class MyIter:2 def __init__(self,x):3 self.x = x45 def __iter__(self): 6 return iter(self) #实例化后就是一个可迭代对象78 def __next__(self): 9 if self.x &gt; 100: #设置抛出StopIteration的条件10 raise StopIteration 11 self.x += 112 return self.x 实现一个反向迭代器协议： 1class Inverse:2 def __init__(self,start):3 self.start = start45 def __iter__(self):6 x = self.start7 while x &gt; 0:8 yield x9 x -= 1","categories":[{"name":"Python","slug":"Python","permalink":"https://newbeenoob.github.io/categories/Python/"},{"name":"漫谈系列","slug":"Python/漫谈系列","permalink":"https://newbeenoob.github.io/categories/Python/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://newbeenoob.github.io/tags/Python/"}]},{"title":"漫谈python特性：生成器Yield的用法","slug":"我的第一条博客","date":"2019-12-05T14:44:06.000Z","updated":"2019-12-06T10:04:05.007Z","comments":true,"path":"posts/b4a8a7cc/","link":"","permalink":"https://newbeenoob.github.io/posts/b4a8a7cc/","excerpt":"","text":"最简单的生成器使用 首先从最简单的自定义长度列表说起：在刚开始接触 python 的时候，由于沿袭了 C 的习惯；我会这样写： 1def lystgen(num):2 n = 03 a = []4 while n &lt; num:5 a.append(n)6 n += 1 同样还有面向对象的写法： 1class lystgen:2 def __init__(self,x):3 self.a = x4 self.b = 05 def __iter__(self):6 return self7 def __next__(self):8 while self.b &lt; self.a:9 res = self.b10 self.b += 111 return res12 # 不断调用 next 方法 这种方法 调用 next 函数才会返回值 不会一次返回一个大的列表；我们还可以再改良代码，这就需要使用关键字 yield 了。 下面是一个例程；用 yield 生成一个惰性序列 返回20以内所有奇数： 1def lazy_iter(num):2 n = 13 print(\"getting started\")4 while n &lt; num:5 yield n6 n += 278for item in lazy_iter(20):9 print(item) 任何一个带有yield语句的函数都是一个生成器，当你直接调用这个函数时，内部的代码是不会被执行的，只有调用yield里面的next函数才会去执行代码， 而for循环可以自动去调用这个next函数来输出值。 yield 可以理解成 return ；其功能是可以中断函数，中断后再次调用时继续从上一次中断的位置继续执行代码并返回值。（相当于 yield 在程序中扮演了给运行例程存档后又读档的角色）。 使用 yield 计算斐波那契数列1# 生成器 fib_generator 2def fib_gen():3 p,q = 1,14 while True:5 yield p6 p,q = q,p + q7 8# 根据 num 不断执行 next() 返回对应的斐波那契数字9def fib(num):10 it = fib_gen() # 这里 it 是一个生成器对象 （ generator object ）11 for i in range(num):12 cur = next(it) 13 return cur 生成器对象也是一个可迭代物；所以也可以使用 for 对其进行遍历 for 会自动调用 next() 从而不再需要手动调用。 下面是使用列表生成式 生成一个小于60的斐波那契数列。 1new_it = fib_gen(60)2fib_lyst = [item for item in new_it]","categories":[{"name":"Python","slug":"Python","permalink":"https://newbeenoob.github.io/categories/Python/"},{"name":"漫谈系列","slug":"Python/漫谈系列","permalink":"https://newbeenoob.github.io/categories/Python/%E6%BC%AB%E8%B0%88%E7%B3%BB%E5%88%97/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://newbeenoob.github.io/tags/Python/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-12-05T03:35:56.840Z","updated":"2019-12-06T10:04:04.992Z","comments":true,"path":"posts/4a17b156/","link":"","permalink":"https://newbeenoob.github.io/posts/4a17b156/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}